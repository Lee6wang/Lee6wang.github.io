---
title: "三相电压源逆变器PWM技术"
date: 2026-01-22 14:00:00 +0800
categories: [Engineering，Motor Control]
tags: [PMSM]
math: true
---

# 三相电压源逆变器PWM技术

## 写在前面

>本文为个人学习笔记，主要参考文献为  
>**《现代永磁同步电机控制原理及 MATLAB 仿真》—— 袁雷 编著**。
>文中部分公式推导与图示均源自该书，特此致谢！

## 一、三相电量的空间矢量表示

SVPWM 算法本质上是一种针对交流电机中三相电压源逆变器功率器件的**特殊开关触发顺序与脉宽组合方式**。通过合理安排开关状态及其作用时间，可以在定子绕组中合成三相相位互差 $120^\circ$、波形畸变较小的正弦电流。

大量理论分析与工程实践表明，与传统的 SPWM 技术相比，SVPWM 具有以下优势：

- SVPWM 对谐波的抑制效果更好，输出电流正弦性更优，同时算法结构清晰，易于实现；
- SVPWM 提高了直流母线电压的利用率，改善了系统的动态响应性能，并有效减小了电机转矩脉动；
- SVPWM 更适合于数字控制系统，尤其适用于 DSP / MCU 等嵌入式平台。

在当前阶段的理解中，只需明确 **SVPWM 的综合性能优于 SPWM** 即可，其具体原理将在后文逐步展开。

在三相 DC/AC 逆变器或 AC/AC 变流器控制中，通常需要分别描述三相变量。若能将三相标量变量合成为一个空间矢量，并在此过程中保持信息的完整性，则三相系统问题便可等效为单相问题，从而大幅简化分析与控制过程。

---

### 1.1 三相标量变量的空间矢量表示

假设三相3个标量分别为 $x_a, x_b, x_c$，且满足 $x_a + x_b + x_c = 0$ ，则其空间矢量表示为：

$$
\vec{X}_{out} = x_a + x_b e^{j\frac{2\pi}{3}} + x_c e^{j\frac{4\pi}{3}}
\tag{1}
$$

式（1）的变换将3个标量变量转换为一个复数变量，且信息完整。式（1）中，$e^{j\frac{2\pi}{3}}$ 和 $e^{j\frac{4\pi}{3}}$ 分别表示相位差120°和240°的两个单位矢量。
其实部和虚部分别为：

$$
\left\{
\begin{array}{l}
\operatorname{Re}\, \vec{X}_{\text{out}}= x_a + x_b \cos\left(\frac{2\pi}{3}\right)+ x_c \cos\left(-\frac{2\pi}{3}\right) \\
\operatorname{Im}\, \vec{X}_{\text{out}}= x_b \sin\left(\frac{2\pi}{3}\right)+ x_c \sin\left(-\frac{2\pi}{3}\right)
\end{array}
\right.
\tag{2}
$$

![1](../assets/figure/2026-01-22/1.png)

将（2）中两式和$x_a + x_b + x_c = 0$并联得：

$$
\begin{bmatrix}
\operatorname{Re} X_{\text{out}} \\
\operatorname{Im} X_{\text{out}} \\
0
\end{bmatrix}=
\begin{bmatrix}
1 & -\frac{1}{2} & -\frac{1}{2} \\
0 & \frac{\sqrt{3}}{2} & -\frac{\sqrt{3}}{2} \\
\frac{1}{2} & \frac{1}{2} & \frac{1}{2}
\end{bmatrix}
\begin{bmatrix}
x_a \\
x_b \\
x_c
\end{bmatrix}
\tag{3}
$$

如果$\vec{X}_{\text{out}}$已知，可得出：

$$
\begin{bmatrix}
x_a \\
x_b \\
x_c
\end{bmatrix}=
\begin{bmatrix}
1 & 0 & 1 \\
-\frac{1}{2} & \frac{\sqrt{3}}{2} & 1 \\
-\frac{1}{2} & -\frac{\sqrt{3}}{2} & 1
\end{bmatrix}
\begin{bmatrix}
\operatorname{Re} X_{\text{out}} \\
\operatorname{Im} X_{\text{out}} \\
0
\end{bmatrix}
\tag{4}
$$

假设三相对称正弦相电压的瞬时值表示为：

$$
\left\{
\begin{array}{l}
u_a = U_m \sin \omega t \\
u_b = U_m \sin \left(\omega t - \frac{2\pi}{3}\right) \\
u_c = U_m \sin \left(\omega t + \frac{2\pi}{3}\right)
\end{array} \right.
\tag{5}
$$

其中$U_m$为相电压的幅值，$\omega = 2\pi f$为电角频率。
三相相电压的空间矢量表示为：

$$
\vec{U}_{out} = u_a + au_b + a^2 u_c = U_m \left[\sin \omega t + a \sin \left(\omega t - \frac{2\pi}{3}\right) + a^2 \sin \left(\omega t + \frac{2\pi}{3}\right)\right]
\tag{6}
$$

上面这个式子里面出现的$a$和$a^2$，分别表示$e^{j\frac{2\pi}{3}}$和$e^{j\frac{4\pi}{3}}$。
代表将$b$相和$c$相的电压分别旋转120°和240°后再进行叠加。

可求出电压矢量$\vec{U}_{out}$的实部和虚部：

$$
\begin{cases}
\operatorname{Re} U_{\text{out}}= u_a + u_b \cos\left(\frac{2\pi}{3}\right)+ u_c \cos\left(-\frac{2\pi}{3}\right)= \dfrac{3}{2} U_m \sin \omega t \\[8pt]
\operatorname{Im} U_{\text{out}}= u_b \sin\left(\frac{2\pi}{3}\right)+ u_c \sin\left(-\frac{2\pi}{3}\right)= -\dfrac{3}{2} U_m \cos \omega t
\end{cases}
\tag{7}
$$

电压空间矢量$\vec{U}_{out}$为

$$
U_{\text{out}}= \operatorname{Re} U_{\text{out}} + j\,\operatorname{Im} U_{\text{out}}= \frac{3}{2} U_m e^{j\left(\omega t - \frac{\pi}{2}\right)}
\tag{8}
$$

![2](../assets/figure/2026-01-22/2.png)
可以很轻易的得出，三相对称正弦电压对应的空间电压矢量运动轨迹是一个圆，如上图所示。
这是一个以$\frac{3}{2} U_m$为半径、以原点为圆心的圆，且其旋转方向与三相电压的相序相同，且转速为$\omega$。

---

### 1.2 空间矢量的六个基本位置

对于典型的两电平三相电压源逆变器电路，如下图所示：
![3](../assets/figure/2026-01-22/3.png)
其每个桥臂有两个开关管，分别记为$S_{A+}, S_{A-}, S_{B+}, S_{B-}, S_{C+}, S_{C-}$。当上桥臂开关闭合时，记为1；当下桥臂开关闭合时，记为0。则三相逆变器的工作状态可用一个三位二进制数表示，共有8种工作状态，如下表所示：

| 状态 | $S_{A+}$ | $S_{B+}$ | $S_{C+}$ | 空间矢量位置 |
| ---- | -------- | -------- | -------- | ------------ |
| 0    | 0        | 0        | 0        | 0($U_0$)     |
| 1    | 0        | 0        | 1        | $U_1$        |
| 2    | 0        | 1        | 0        | $U_2$        |
| 3    | 0        | 1        | 1        | $U_3$        |
| 4    | 1        | 0        | 0        | $U_4$        |
| 5    | 1        | 0        | 1        | $U_5$        |
| 6    | 1        | 1        | 0        | $U_6$        |
| 7    | 1        | 1        | 1        | 0($U_7$)     |

可以看出，三相逆变器有6个有效的开关状态，对应6个非零的空间矢量位置，另外还有两个零矢量位置（状态0和状态7）。这6个有效的空间矢量位置分别位于空间矢量图的六个扇区的边界上，如下图所示：
![4](../assets/figure/2026-01-22/4.png)

---

## 二、SVPWM的基本原理

### 2.1 SVPWM的基本思想

SVPWM的基本思想是通过选择适当的开关状态组合，使得逆变器输出的空间电压矢量在一个开关周期$T_s$内近似于所需的参考电压矢量。具体来说，在每个采样周期内，参考电压矢量可以表示为六个基本空间矢量和两个零矢量的线性组合。

以扇区1为例,空间矢量合成如下图所示:
![5](../assets/figure/2026-01-22/5.png)

根据平衡等效原则可以得到下式：

$$
\vec{U}_{\text{ref}} T_s = U_4 T_4 + U_6 T_6 + 0 \cdot T_0
\tag{9}
$$

$$
T_s = T_4 + T_6 + T_0
\tag{10}
$$

$$
\begin{cases}
U_1 = \dfrac{T_4}{T_s}\, U_4 \\[6pt]
U_2 = \dfrac{T_6}{T_s}\, U_6
\end{cases}
\tag{11}
$$

其中：$T_4, T_6, T_0$ 分别为作用于 $U_4, U_6, 0$ 矢量的时间。

要合成所需的电压空间矢量，只需计算出$T_4, T_6, T_0$的值即可。可得：

$$
\frac{\lvert U_{\text{out}} \rvert}{\sin\left(\frac{2\pi}{3}\right)}=
\frac{\lvert U_1 \rvert}{\sin\left(\frac{\pi}{3} - \theta\right)}=
\frac{\lvert U_2 \rvert}{\sin \theta}
\tag{12}
$$

其中$\theta$为参考电压矢量$\vec{U}_{\text{out}}$与基本矢量$U_1$之间的夹角。

与式（11）以及幅值关系结合，可得：

$$
\begin{cases}
T_4= \sqrt{3}\,\dfrac{U_m}{U_{\mathrm{dc}}}\, T_s
\sin\!\left(\dfrac{\pi}{3} - \theta\right) \\[8pt]
T_6= \sqrt{3}\,\dfrac{U_m}{U_{\mathrm{dc}}}\, T_s
\sin \theta \\[8pt]
T_0 = T_7= \dfrac{1}{2}\left(T_s - T_4 - T_6\right)
\end{cases}
\tag{13}
$$

定义SVPWM的调制比$M$为：

$$
M = \dfrac{\sqrt{3}U_m}{U_{\mathrm{dc}}}
\tag{14}
$$

在SVPWM中，调制比$M$的最大值为1.15，而在SPWM中，调制比$M$的最大值为1。因此，在相同的直流母线电压下，SVPWM能够输出更高幅值的交流电压，从而提高了直流电压的利用率。

---

### 2.2 基于软件模式的SVPWM

SVPWM算法主要有两种，一种是基于软件模式的合成（七段式），另外一种是基于硬件模式的合成（五段式）。

可列出下表：

![6](../assets/figure/2026-01-22/6.png)
![7](../assets/figure/2026-01-22/7.png)

---

### 2.3 基于硬件模式的SVPWM

对于七段式 SVPWM 算法而言，PWM 波形对称，且谐波含量较小，但是每个开关周期有 6 次开关切换 。 为了进一步减少开关次数，可以采用基于硬件模式的合成方式（五段式 SVPWM 算法），该方法采用每相开关器件在每个扇 区状态维持不变的序列安排下，使得每个开关周期只有 3 次开关切换，但是会增大电流的谐波含量。$\vec{U}_{out}$所在的位置和开关切换顺序如下表所示：

![8](../assets/figure/2026-01-22/8.png)
![9](../assets/figure/2026-01-22/9.png)

---

## 三、SVPWM算法的实现

在前面我们已经知道，SVPWM算法的核心是通过选择适当的开关状态组合，使得逆变器输出的空间电压矢量在一个开关周期内近似于所需的参考电压矢量。下面我们来看看SVPWM算法的具体实现步骤：

### 3.1 参考电压矢量的扇区判断

判断电压空间矢量$\vec{U}_{out}$所在扇区的目的是确定本开关周期所使用的基本电压空间矢量。
用$u_{\alpha}$，$u_{\beta}$表示参考电压矢量$\vec{U}_{out}$的在$\alpha\beta$轴上的分量，定义$U_{ref1}$、$U_{ref2}$、$U_{ref3}$三个变量，则可以列出：

$$
\begin{cases}
U_{\text{ref}1} = u_\beta \\[6pt]
U_{\text{ref}2}= \dfrac{\sqrt{3}}{2}\,u_\alpha - \dfrac{1}{2}\,u_\beta \\[8pt]
U_{\text{ref}3}= -\dfrac{\sqrt{3}}{2}\,u_\alpha - \dfrac{1}{2}\,u_\beta
\end{cases}
\tag{15}
$$

再定义3个变量$A$、$B$、$C$，可以得出：
若$U_{\text{ref}1}>0$，则$A=1$；否则$A=0$
若$U_{\text{ref}2}>0$，则$B=1$；否则$B=0$
若$U_{\text{ref}3}>0$，则$C=1$；否则$C=0$

令$N = 4A + 2B + C$，根据这些变量的值，根据下表，可以判断出参考电压矢量所在的扇区。

| N    | 3   | 1   | 5   | 4   | 6   | 2   |
| ---- | --- | --- | --- | --- | --- | --- |
| 扇区 | 1   | 2   | 3   | 4   | 5   | 6   |

除此之外，还可以通过参考电压矢量$\vec{U}_{out}$的角度来判断其所在的扇区。如下图所示：
![10](../assets/figure/2026-01-22/10.png)

---

### 3.2 非零矢量和零矢量作用时间的计算

确定参考电压矢量$\vec{U}_{out}$所在的扇区后，即可根据式（13）计算出非零矢量$T_{on1}$、$T_{on2}$和零矢量$T_0$的作用时间。

$$
\begin{cases}
u_\alpha= \dfrac{T_4}{T_s}\,\lvert U_4 \rvert+ \dfrac{T_6}{T_s}\,\lvert U_6 \rvert \cos\!\left(\dfrac{\pi}{3}\right) \\[8pt]
u_\beta= \dfrac{T_6}{T_s}\,\lvert U_6 \rvert \sin\!\left(\dfrac{\pi}{3}\right)
\end{cases}
\tag{16}
$$

可以变为：

$$
\begin{cases}
T_4= \dfrac{\sqrt{3}\,T_s}{2\,U_{\mathrm{dc}}}
\left(\sqrt{3}\,u_\alpha - u_\beta\right) \\[8pt]
T_6= \dfrac{\sqrt{3}\,T_s}{2\,U_{\mathrm{dc}}}\, u_\beta
\end{cases}
\tag{17}
$$

同理可得，其他扇区个矢量的作用时间。令

$$
\begin{cases}
X= \dfrac{\sqrt{3}\,T_s}{U_{\mathrm{dc}}}\,u_\beta \\[8pt]
Y= \dfrac{\sqrt{3}\,T_s}{U_{\mathrm{dc}}}
\left(
\dfrac{\sqrt{3}}{2}\,u_\alpha+ \dfrac{1}{2}\,u_\beta
\right) \\
Z= \dfrac{\sqrt{3}\,T_s}{U_{\mathrm{dc}}}
\left(-\dfrac{\sqrt{3}}{2}\,u_\alpha+ \dfrac{1}{2}\,u_\beta
\right)
\end{cases}
\tag{18}
$$

可以得到各个扇区作用的时间如下所示：

| N   | 1                                       | 2   | 3   | 4   | 5   | 6   |
| --- | --------------------------------------- | --- | --- | --- | --- | --- |
| T₄  | Z                                       | Y   | −Z  | −X  | X   | −Y  |
| T₆  | Y                                       | −X  | X   | Z   | −Y  | −Z  |
| T₀  | ${T_0(T_7)=\dfrac{T_s - T_4 - T_6}{2}}$ |

如果$T_4+T_6>T_s$，则需要对$T_4$和$T_6$进行缩放：

$$
\begin{cases}
T_4= \dfrac{T_4 T_s}{T_4 + T_6} \\[8pt]
T_6= \dfrac{T_6 T_s}{T_4 + T_6}
\end{cases}
\tag{19}
$$

如果$T_4<0$，则令$T_4=0$，同理如果$T_6<0$，则令$T_6=0$。

---

### 3.3 扇区矢量切换点的确认

首先定义：

$$
\begin{cases}
T_a = \dfrac{T_s - T_4 - T_6}{4} \\[6pt]
T_b = T_a + \dfrac{T_4}{2} \\[6pt]
T_c = T_b + \dfrac{T_6}{2}
\end{cases}
\tag{20}
$$

则三相电压开关时间切换点$T_{cm1}$、$T_{cm2}$、$T_{cm3}$如下所示：

| N         | 1     | 2     | 3     | 4     | 5     | 6     |
| --------- | ----- | ----- | ----- | ----- | ----- | ----- |
| $T_{cm1}$ | $T_b$ | $T_a$ | $T_a$ | $T_c$ | $T_c$ | $T_b$ |
| $T_{cm2}$ | $T_a$ | $T_c$ | $T_b$ | $T_b$ | $T_a$ | $T_c$ |
| $T_{cm3}$ | $T_c$ | $T_b$ | $T_c$ | $T_a$ | $T_b$ | $T_a$ |

---

## 四、SVPWM 的 C 代码实现（工程模板）

本节给出一套**可直接移植到 MCU/DSP** 的 SVPWM 工程化实现框架。实现目标是：输入参考电压在 \(\alpha\beta\) 坐标系下的分量 \((u_\alpha, u_\beta)\)，以及采样周期 \(T_s\)、直流母线电压 \(U_{dc}\)，输出三相比较值（或占空比）对应的切换点 \(T_{cm1}, T_{cm2}, T_{cm3}\)。

为与前文推导完全一致，本节沿用式（15）～（20）的符号体系，并使用式（18）的 \(X,Y,Z\) 作为中间量，通过扇区表计算 \(T_4,T_6\)，再由式（20）得到 \(T_a,T_b,T_c\)，最后根据表格完成 \(T_{cm1},T_{cm2},T_{cm3}\) 的映射。

> 说明：本文给出的是**对称七段式 SVPWM** 的“比较值/切换点”输出形式，便于直接对接定时器中心对齐（Center-aligned）PWM。

---

### 4.1 数据结构与工具函数

```c
#include <math.h>
#include <stdint.h>

typedef struct
{
    float Ts;     // 开关周期 Ts
    float Udc;    // 直流母线电压 Udc

    // 输出：三相比较切换点（或可理解为归一化占空等价量，取决于你如何对接定时器）
    float Tcm1;
    float Tcm2;
    float Tcm3;

    // 可选输出：扇区号（1~6）
    uint8_t sector;

    // 可选输出：非零矢量与零矢量作用时间
    float T4, T6, T0;
} SVPWM_Out;

static inline float clampf(float x, float lo, float hi)
{
    if (x < lo) return lo;
    if (x > hi) return hi;
    return x;
}
```

### 4.2 扇区判断（对应式（15））

```c
static inline uint8_t svpwm_sector_from_uab(float u_alpha, float u_beta)
{
    // 式（15）
    float Uref1 = u_beta;
    float Uref2 = 0.8660254037844386f * u_alpha - 0.5f * u_beta;   // sqrt(3)/2 * u_alpha - 1/2 * u_beta
    float Uref3 = -0.8660254037844386f * u_alpha - 0.5f * u_beta;  // -sqrt(3)/2 * u_alpha - 1/2 * u_beta

    uint8_t A = (Uref1 > 0.0f) ? 1 : 0;
    uint8_t B = (Uref2 > 0.0f) ? 1 : 0;
    uint8_t C = (Uref3 > 0.0f) ? 1 : 0;

    uint8_t N = (uint8_t)(4U * A + 2U * B + 1U * C);

    // 根据对照表：
    // N: 3  1  5  4  6  2
    // 扇区:1  2  3  4  5  6
    switch (N)
    {
        case 3: return 1;
        case 1: return 2;
        case 5: return 3;
        case 4: return 4;
        case 6: return 5;
        case 2: return 6;
        default: return 0; // 落在边界/数值误差时可能出现 0 或 7，工程上可做兜底处理
    }
}
```

---

4.3 计算 $X$/$Y$/$Z$（对应式（18））

```c
static inline void svpwm_calc_XYZ(float u_alpha, float u_beta, float Ts, float Udc,
                                 float *X, float *Y, float *Z)
{
    const float K = (1.7320508075688772f * Ts) / Udc; // sqrt(3)*Ts/Udc

    *X = K * u_beta;

    *Y = K * (0.8660254037844386f * u_alpha + 0.5f * u_beta);   // (sqrt(3)/2)u_alpha + (1/2)u_beta
    *Z = K * (-0.8660254037844386f * u_alpha + 0.5f * u_beta);  // -(sqrt(3)/2)u_alpha + (1/2)u_beta
}
```

---

### 4.4 计算 $T_4$、$T_6$、$T_0$（对应表格与式（19））

```c
static inline void svpwm_calc_T4T6T0(uint8_t sector, float X, float Y, float Z, float Ts,
                                    float *T4, float *T6, float *T0)
{
    float t4 = 0.0f, t6 = 0.0f;

    switch (sector)
    {
        case 1: t4 =  Z; t6 =  Y; break;
        case 2: t4 =  Y; t6 = -X; break;
        case 3: t4 = -Z; t6 =  X; break;
        case 4: t4 = -X; t6 =  Z; break;
        case 5: t4 =  X; t6 = -Y; break;
        case 6: t4 = -Y; t6 = -Z; break;
        default:
            t4 = 0.0f; t6 = 0.0f; break;
    }

    // 负值钳位
    if (t4 < 0.0f) t4 = 0.0f;
    if (t6 < 0.0f) t6 = 0.0f;

    // 若 T4 + T6 > Ts，按式（19）缩放
    float sum = t4 + t6;
    if (sum > Ts && sum > 0.0f)
    {
        float scale = Ts / sum;
        t4 *= scale;
        t6 *= scale;
    }

    float t0 = 0.5f * (Ts - t4 - t6);
    if (t0 < 0.0f) t0 = 0.0f;

    *T4 = t4;
    *T6 = t6;
    *T0 = t0;
}
```

---

### 4.5 计算$T_a$、$T_b$、$T_c$（对应式（20））

```c
static inline void svpwm_calc_Tabc(float Ts, float T4, float T6, float *Ta, float *Tb, float *Tc)
{
    // 式（20）
    float ta = 0.25f * (Ts - T4 - T6);
    float tb = ta + 0.5f * T4;
    float tc = tb + 0.5f * T6;

    // 工程上可再做一次边界保护
    ta = clampf(ta, 0.0f, Ts);
    tb = clampf(tb, 0.0f, Ts);
    tc = clampf(tc, 0.0f, Ts);

    *Ta = ta;
    *Tb = tb;
    *Tc = tc;
}
```

---

### 4.6 由扇区映射三相比较切换点 $Tcm1$/$Tcm2$/$Tcm3$

```c
static inline void svpwm_map_Tcm(uint8_t sector, float Ta, float Tb, float Tc,
                                 float *Tcm1, float *Tcm2, float *Tcm3)
{
    float t1=0.0f, t2=0.0f, t3=0.0f;

    switch (sector)
    {
        case 1: t1 = Tb; t2 = Ta; t3 = Tc; break;
        case 2: t1 = Ta; t2 = Tc; t3 = Tb; break;
        case 3: t1 = Ta; t2 = Tb; t3 = Tc; break;
        case 4: t1 = Tc; t2 = Tb; t3 = Ta; break;
        case 5: t1 = Tc; t2 = Ta; t3 = Tb; break;
        case 6: t1 = Tb; t2 = Tc; t3 = Ta; break;
        default: t1 = t2 = t3 = 0.0f; break;
    }

    *Tcm1 = t1;
    *Tcm2 = t2;
    *Tcm3 = t3;
}
```

---

### 4.7 SVPWM 主函数

```c
void SVPWM_Compute(float u_alpha, float u_beta, float Ts, float Udc, SVPWM_Out *out)
{
    // 1) 扇区判断
    uint8_t sec = svpwm_sector_from_uab(u_alpha, u_beta);
    if (sec == 0)
    {
        // 边界兜底：可选择保持上一次扇区，或直接归零
        // 这里简单归零
        out->sector = 0;
        out->Tcm1 = out->Tcm2 = out->Tcm3 = 0.0f;
        out->T4 = out->T6 = out->T0 = 0.0f;
        return;
    }

    // 2) 计算 X/Y/Z
    float X, Y, Z;
    svpwm_calc_XYZ(u_alpha, u_beta, Ts, Udc, &X, &Y, &Z);

    // 3) 查表得到 T4/T6/T0 + 工程修正
    float T4, T6, T0;
    svpwm_calc_T4T6T0(sec, X, Y, Z, Ts, &T4, &T6, &T0);

    // 4) 计算 Ta/Tb/Tc
    float Ta, Tb, Tc;
    svpwm_calc_Tabc(Ts, T4, T6, &Ta, &Tb, &Tc);

    // 5) 映射三相比较切换点
    float Tcm1, Tcm2, Tcm3;
    svpwm_map_Tcm(sec, Ta, Tb, Tc, &Tcm1, &Tcm2, &Tcm3);

    // 输出
    out->Ts = Ts;
    out->Udc = Udc;
    out->sector = sec;

    out->T4 = T4;
    out->T6 = T6;
    out->T0 = T0;

    out->Tcm1 = Tcm1;
    out->Tcm2 = Tcm2;
    out->Tcm3 = Tcm3;
}
```

---

---

## 五、三相电压源逆变器的物理限制与工程约束

前文在推导 SVPWM 算法时，默认逆变器的开关器件可以**理想、瞬时、无限快地完成导通与关断**，且直流母线、电机、电流采样均不存在任何非理想因素。然而在实际工程中，三相电压源逆变器的运行始终受到功率器件、电源与负载等多方面的**物理限制**。

本节从工程实现角度，对三相逆变器在 SVPWM 控制下所面临的主要物理约束进行分析，重点讨论**最大开关频率、最小脉宽、电压与电流限制**等问题。

---

### 5.1 功率开关器件的最大开关频率限制

在三相逆变器中，功率器件通常采用 MOSFET 或 IGBT。无论采用哪种器件，其开关过程都不是瞬时完成的，而是存在**有限的开通时间与关断时间**。

以单个功率器件为例，其一次完整开关过程至少包括：

- 栅极充放电延迟；
- 器件电压、电流交叠变化过程；
- 驱动电路传播延迟；
- 死区时间（Dead Time）。

设功率器件的最小可靠导通或关断时间为 $t_{\text{sw}}$，则单个开关周期内允许的最大开关次数是受限的。若开关频率过高，将导致：

- 器件尚未完全导通即开始关断，等效占空比失真；
- 开关损耗显著增加，结温升高；
- 严重时可能引发器件击穿或保护动作。

因此，逆变器的开关频率 $f_s$ 必须满足：

$$
f_s \ll \frac{1}{t_{\text{sw}}}
$$

在实际工程中，通常保留较大的裕量。例如：

- MOSFET：常见开关频率为 10 kHz ～ 40 kHz；
- IGBT：常见开关频率为 2 kHz ～ 20 kHz。

SVPWM 本身并不会突破这一限制，**但过高的调制频率会直接暴露硬件瓶颈**。

---

### 5.2 最小脉宽限制

在 SVPWM 中，非零矢量的作用时间 $T_4, T_6$ 是连续变化的。当参考电压矢量幅值较小或位于扇区边界附近时，可能出现：

$$
T_4 \to 0 \quad \text{或} \quad T_6 \to 0
$$

然而在实际逆变器中，功率器件和驱动电路均存在一个**最小可识别脉宽** $T_{\min}$，当作用时间小于该值时：

- 开关器件可能无法完成有效导通；
- 输出电压与理论值不一致；
- 电流采样结果失真。

因此在工程实现中通常需要满足：

$$
T_4 \ge T_{\min}, \quad T_6 \ge T_{\min}
$$

若计算得到的 $T_4$ 或 $T_6$ 小于该阈值，通常采用以下处理方式之一：

- 将该作用时间直接钳位为 0；
- 合并为零矢量时间；
- 降低调制比或限制参考电压幅值。

这也是为什么在实际 SVPWM 实现中，**低速小电压区的波形失真往往比理论分析更明显**。

---

### 5.3 死区时间（Dead Time）引入的电压误差

为防止同一桥臂上下管直通，三相逆变器在切换时必须引入死区时间 $t_d$。死区的存在会导致：

- 实际输出相电压与理论值不完全一致；
- 电压误差与电流方向相关；
- 在低速、低电压区尤为明显。

在 SVPWM 中，死区效应会破坏理想的空间矢量合成关系，使得：

- 合成电压矢量幅值减小；
- 相位发生偏移；
- 电流波形畸变，转矩脉动增加。

因此在高性能电机控制中，常需要引入**死区补偿算法**，其本质是根据电流方向修正等效作用时间。

---

### 5.4 直流母线电压与调制比的物理上限

在理想条件下，SVPWM 的最大调制比为：

$$
M_{\max} = \frac{\sqrt{3} U_m}{U_{\mathrm{dc}}} \approx 1.15
$$

但在实际系统中，以下因素会降低可用的最大调制比：

- 直流母线电压波动；
- 器件导通压降；
- 死区时间引入的等效电压损失；
- 控制算法与采样延迟。

因此在工程实现中，通常会人为限制调制比：

$$
M \le 0.9 \sim 1.0
$$

以保证系统在极端工况下仍具有稳定裕量。这也是很多电机控制程序中，会看到对 $u_\alpha, u_\beta$ 或 $U_{\text{ref}}$ 进行**幅值限幅**的原因。

---

### 5.5 电流与热限制对 SVPWM 的间接影响

SVPWM 本身并不直接限制电流，但逆变器和电机系统始终受限于：

- 功率器件最大电流；
- 电机定子允许电流；
- 散热条件与结温限制。

当参考电压过大或电机处于重载工况时，SVPWM 可能会在短时间内产生较大的电压矢量，从而引发电流陡升。因此在实际控制系统中，SVPWM 通常与：

- 电流环限幅；
- 电压矢量限幅；
- 过流保护逻辑

协同工作，而不是孤立运行。

---

### 总结：理想算法与真实硬件之间的差距

综上所述，SVPWM 的数学推导建立在理想假设之上，而真实三相逆变器则受到多种物理约束。可以总结为：

- **SVPWM 决定“应该输出什么电压”**；
- **逆变器硬件决定“是否真的能输出该电压”**。

理解这些物理限制，有助于在工程实践中：

- 合理选择开关频率；
- 设置调制比与限幅策略；
- 正确看待仿真结果与实验结果之间的差异。

这也是从“算法正确”迈向“系统可靠”的关键一步。

希望本文对理解 SVPWM 在实际逆变器中的应用有所帮助！

---
